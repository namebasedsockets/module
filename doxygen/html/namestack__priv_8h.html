<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Name-based sockets - module: namestack_priv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>namestack_priv.h File Reference</h1><code>#include &lt;linux/types.h&gt;</code><br/>
<code>#include &lt;linux/socket.h&gt;</code><br/>
<code>#include &lt;net/sock.h&gt;</code><br/>
<code>#include &lt;linux/inname.h&gt;</code><br/>
<div class="dynheader">
Include dependency graph for namestack_priv.h:</div>
<div class="dynsection">
</div>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
</div>

<p><a href="namestack__priv_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structname__stream__sock.html">name_stream_sock</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#aa467a35f7adb45db01b0a959525737a5">query_resolv_cb</a> )(const __u8 *response, int len, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#ae0ee61a92e06c6d36d46f60beef3d27d">qualify_cb</a> )(const char *name, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#abc9db88094d622c5f1f6b811da3c9693">register_cb</a> )(int result, const char *name, void *data)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structname__stream__sock.html">name_stream_sock</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#a5e5b37b81978789054ddc587e3af21e6">name_stream_sk</a> (const struct sock *sk)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#aba97cdc2d426374e9a939e5cd64f3c6d">name_af_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#ac37ce9d7d05a92ecd217351dfc571834">name_af_exit</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#af9ebf7c5c4b9e21647f9fad73789d1c4">name_send_query</a> (const char *name, <a class="el" href="namestack__priv_8h.html#aa467a35f7adb45db01b0a959525737a5">query_resolv_cb</a> cb, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#aee0a1ed42b28379c58f090c8b5d06aa5">name_cancel_query</a> (void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#a749ca3e8a89fd3bfb9ea9c4d40d53697">choose_addresses</a> (int *num_v6_addresses, struct in6_addr **v6_addresses, int *num_v4_addresses, __be32 **v4_addresses)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#a16f51d1d1829f7c23407fcbf17139691">match_v6_address_to_scope</a> (struct sockaddr_in6 *sin6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#a747de89e52fd69f30633dadae20e2c45">choose_scope_for_v6_address</a> (struct sockaddr_in6 *sin6)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#ac90990b1e38414ac068ce97f0c469e4e">name_fully_qualify</a> (const char *name, <a class="el" href="namestack__priv_8h.html#ae0ee61a92e06c6d36d46f60beef3d27d">qualify_cb</a> cb, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#ab952bacca3b7e5f0795ba6304a36cfd4">name_send_registration</a> (const char *name, const struct in6_addr *v6_addresses, int num_v6_addresses, const __be32 *v4_addresses, int num_v4_addresses, <a class="el" href="namestack__priv_8h.html#abc9db88094d622c5f1f6b811da3c9693">register_cb</a> cb, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#a8bda9733b25a90bc533e4503c32830ad">name_delete_registration</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#a29317552ae54d25f0c09131c2494625b">name_cache_init</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#aa6e1ff7767ba286a06b81fe430b0e76f">name_cache_add</a> (const char *name, struct socket *sock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#aa1fb6667246cbfbc4f63436093f59535">name_cache_delete</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namestack__priv_8h.html#aed06704ba74d97061ec306c3f2a408d3">name_cache_free</a> (void)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ae0ee61a92e06c6d36d46f60beef3d27d"></a><!-- doxytag: member="namestack_priv.h::qualify_cb" ref="ae0ee61a92e06c6d36d46f60beef3d27d" args=")(const char *name, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namestack__priv_8h.html#ae0ee61a92e06c6d36d46f60beef3d27d">qualify_cb</a>)(const char *name, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namestack__priv_8h_source.html#l00064">64</a> of file <a class="el" href="namestack__priv_8h_source.html">namestack_priv.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa467a35f7adb45db01b0a959525737a5"></a><!-- doxytag: member="namestack_priv.h::query_resolv_cb" ref="aa467a35f7adb45db01b0a959525737a5" args=")(const __u8 *response, int len, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namestack__priv_8h.html#aa467a35f7adb45db01b0a959525737a5">query_resolv_cb</a>)(const __u8 *response, int len, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namestack__priv_8h_source.html#l00035">35</a> of file <a class="el" href="namestack__priv_8h_source.html">namestack_priv.h</a>.</p>

</div>
</div>
<a class="anchor" id="abc9db88094d622c5f1f6b811da3c9693"></a><!-- doxytag: member="namestack_priv.h::register_cb" ref="abc9db88094d622c5f1f6b811da3c9693" args=")(int result, const char *name, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namestack__priv_8h.html#abc9db88094d622c5f1f6b811da3c9693">register_cb</a>)(int result, const char *name, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namestack__priv_8h_source.html#l00066">66</a> of file <a class="el" href="namestack__priv_8h_source.html">namestack_priv.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a749ca3e8a89fd3bfb9ea9c4d40d53697"></a><!-- doxytag: member="namestack_priv.h::choose_addresses" ref="a749ca3e8a89fd3bfb9ea9c4d40d53697" args="(int *num_v6_addresses, struct in6_addr **v6_addresses, int *num_v4_addresses, __be32 **v4_addresses)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int choose_addresses </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num_v6_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct in6_addr **&nbsp;</td>
          <td class="paramname"> <em>v6_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num_v4_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__be32 **&nbsp;</td>
          <td class="paramname"> <em>v4_addresses</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="address_8c_source.html#l00064">64</a> of file <a class="el" href="address_8c_source.html">address.c</a>.</p>

<p>References <a class="el" href="address_8c_source.html#l00008">print_ip4addr()</a>, and <a class="el" href="address_8c_source.html#l00028">print_ip6addr()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l00918">name_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00066"></a>00066 {
<a name="l00067"></a>00067         <span class="keyword">struct </span>net *net = &amp;init_net;
<a name="l00068"></a>00068         <span class="keyword">struct </span>net_device *dev;
<a name="l00069"></a>00069         <span class="keywordtype">int</span> n_v6_addresses = 0;
<a name="l00070"></a>00070         <span class="keywordtype">int</span> n_v4_addresses = 0;
<a name="l00071"></a>00071         <span class="keyword">struct </span>in6_addr *pv6;
<a name="l00072"></a>00072         __be32 *pv4;
<a name="l00073"></a>00073         <span class="keywordtype">int</span> err;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         <span class="comment">/* FIXME: lock net? */</span>
<a name="l00076"></a>00076         for_each_netdev(net, dev) {
<a name="l00077"></a>00077                 <span class="keywordflow">if</span> (!(dev-&gt;flags &amp; IFF_UP))
<a name="l00078"></a>00078                         <span class="keywordflow">continue</span>;
<a name="l00079"></a>00079                 <span class="keywordflow">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK)
<a name="l00080"></a>00080                         <span class="keywordflow">continue</span>;
<a name="l00081"></a>00081                 <span class="keywordflow">if</span> (dev-&gt;ip6_ptr) {
<a name="l00082"></a>00082                         <span class="keyword">struct </span>inet6_dev *in6 = dev-&gt;ip6_ptr;
<a name="l00083"></a>00083                         <span class="keyword">struct </span>inet6_ifaddr *addr;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085                         <span class="keywordflow">for</span> (addr = in6-&gt;addr_list; addr; addr = addr-&gt;if_next)
<a name="l00086"></a>00086                                 n_v6_addresses++;
<a name="l00087"></a>00087                 }
<a name="l00088"></a>00088                 <span class="keywordflow">if</span> (dev-&gt;ip_ptr) {
<a name="l00089"></a>00089                         <span class="keyword">struct </span>in_device *in4 = dev-&gt;ip_ptr;
<a name="l00090"></a>00090                         <span class="keyword">struct </span>in_ifaddr *addr;
<a name="l00091"></a>00091 
<a name="l00092"></a>00092                         <span class="keywordflow">for</span> (addr = in4-&gt;ifa_list; addr; addr = addr-&gt;ifa_next)
<a name="l00093"></a>00093                                 n_v4_addresses++;
<a name="l00094"></a>00094                 }
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096         err = -ENOMEM;
<a name="l00097"></a>00097         <span class="keywordflow">if</span> (n_v6_addresses) {
<a name="l00098"></a>00098                 *v6_addresses = kmalloc(n_v6_addresses *
<a name="l00099"></a>00099                                         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet6_ifaddr),
<a name="l00100"></a>00100                                         GFP_ATOMIC);
<a name="l00101"></a>00101                 <span class="keywordflow">if</span> (!*v6_addresses)
<a name="l00102"></a>00102                         <span class="keywordflow">goto</span> out;
<a name="l00103"></a>00103                 <span class="keywordflow">else</span>
<a name="l00104"></a>00104                         *num_v6_addresses = n_v6_addresses;
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106         <span class="keywordflow">else</span> {
<a name="l00107"></a>00107                 *v6_addresses = NULL;
<a name="l00108"></a>00108                 *num_v6_addresses = 0;
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110         <span class="keywordflow">if</span> (n_v4_addresses) {
<a name="l00111"></a>00111                 *v4_addresses = kmalloc(n_v4_addresses *
<a name="l00112"></a>00112                                         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_ifaddr),
<a name="l00113"></a>00113                                         GFP_ATOMIC);
<a name="l00114"></a>00114                 <span class="keywordflow">if</span> (!*v4_addresses) {
<a name="l00115"></a>00115                         kfree(*v6_addresses);
<a name="l00116"></a>00116                         <span class="keywordflow">goto</span> out;
<a name="l00117"></a>00117                 }
<a name="l00118"></a>00118                 <span class="keywordflow">else</span>
<a name="l00119"></a>00119                         *num_v4_addresses = n_v4_addresses;
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121         <span class="keywordflow">else</span> {
<a name="l00122"></a>00122                 *v4_addresses = NULL;
<a name="l00123"></a>00123                 *num_v4_addresses = 0;
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125         err = 0;
<a name="l00126"></a>00126         pv6 = *v6_addresses;
<a name="l00127"></a>00127         pv4 = *v4_addresses;
<a name="l00128"></a>00128         for_each_netdev(net, dev) {
<a name="l00129"></a>00129                 <span class="keywordflow">if</span> (!(dev-&gt;flags &amp; IFF_UP))
<a name="l00130"></a>00130                         <span class="keywordflow">continue</span>;
<a name="l00131"></a>00131                 <span class="keywordflow">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK)
<a name="l00132"></a>00132                         <span class="keywordflow">continue</span>;
<a name="l00133"></a>00133                 printk(KERN_INFO <span class="stringliteral">&quot;adding addresses from %s\n&quot;</span>, dev-&gt;name);
<a name="l00134"></a>00134                 <span class="keywordflow">if</span> (dev-&gt;ip6_ptr) {
<a name="l00135"></a>00135                         <span class="keyword">struct </span>inet6_dev *in6 = dev-&gt;ip6_ptr;
<a name="l00136"></a>00136                         <span class="keyword">struct </span>inet6_ifaddr *addr;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138                         <span class="keywordflow">for</span> (addr = in6-&gt;addr_list; addr;
<a name="l00139"></a>00139                              addr = addr-&gt;if_next) {
<a name="l00140"></a>00140                                 <a class="code" href="address_8c.html#a185e915fee84e8d2ccc409fc5e0fafe8">print_ip6addr</a>(&amp;addr-&gt;addr);
<a name="l00141"></a>00141                                 *pv6 = addr-&gt;addr;
<a name="l00142"></a>00142                                 pv6++;
<a name="l00143"></a>00143                         }
<a name="l00144"></a>00144                 }
<a name="l00145"></a>00145                 <span class="keywordflow">if</span> (dev-&gt;ip_ptr) {
<a name="l00146"></a>00146                         <span class="keyword">struct </span>in_device *in4 = dev-&gt;ip_ptr;
<a name="l00147"></a>00147                         <span class="keyword">struct </span>in_ifaddr *addr;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149                         <span class="keywordflow">for</span> (addr = in4-&gt;ifa_list; addr;
<a name="l00150"></a>00150                              addr = addr-&gt;ifa_next) {
<a name="l00151"></a>00151                                 <a class="code" href="address_8c.html#ab7221ae0445f64eb613772f02204cb28">print_ip4addr</a>(&amp;addr-&gt;ifa_address);
<a name="l00152"></a>00152                                 *pv4 = addr-&gt;ifa_address;
<a name="l00153"></a>00153                                 pv4++;
<a name="l00154"></a>00154                         }
<a name="l00155"></a>00155                 }
<a name="l00156"></a>00156         }
<a name="l00157"></a>00157 out:
<a name="l00158"></a>00158         <span class="keywordflow">return</span> err;
<a name="l00159"></a>00159 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a747de89e52fd69f30633dadae20e2c45"></a><!-- doxytag: member="namestack_priv.h::choose_scope_for_v6_address" ref="a747de89e52fd69f30633dadae20e2c45" args="(struct sockaddr_in6 *sin6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int choose_scope_for_v6_address </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_in6 *&nbsp;</td>
          <td class="paramname"> <em>sin6</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="address_8c_source.html#l00189">189</a> of file <a class="el" href="address_8c_source.html">address.c</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l01122">name_stream_connect_to_v6_address()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00190"></a>00190 {
<a name="l00191"></a>00191         <span class="comment">/* FIXME: for now, always picks the first interface with an IPv6</span>
<a name="l00192"></a>00192 <span class="comment">         * address, or the first up interface if that fails.  Should instead:</span>
<a name="l00193"></a>00193 <span class="comment">         * 1. Use the source name&#39;s scope ID, if the socket is bound to a local</span>
<a name="l00194"></a>00194 <span class="comment">         *    name and the local name is a link-local address.</span>
<a name="l00195"></a>00195 <span class="comment">         * 2. Allow choosing among multiple possible interfaces.</span>
<a name="l00196"></a>00196 <span class="comment">         */</span>
<a name="l00197"></a>00197         <span class="keyword">struct </span>net *net = &amp;init_net;
<a name="l00198"></a>00198         <span class="keyword">struct </span>net_device *dev;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="comment">/* FIXME: lock net? */</span>
<a name="l00201"></a>00201         for_each_netdev(net, dev) {
<a name="l00202"></a>00202                 <span class="keywordflow">if</span> (!(dev-&gt;flags &amp; IFF_UP))
<a name="l00203"></a>00203                         <span class="keywordflow">continue</span>;
<a name="l00204"></a>00204                 <span class="keywordflow">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK)
<a name="l00205"></a>00205                         <span class="keywordflow">continue</span>;
<a name="l00206"></a>00206                 <span class="keywordflow">if</span> (dev-&gt;ip6_ptr) {
<a name="l00207"></a>00207                         <span class="keyword">struct </span>inet6_dev *in6 = dev-&gt;ip6_ptr;
<a name="l00208"></a>00208                         <span class="keyword">struct </span>inet6_ifaddr *addr;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210                         <span class="keywordflow">for</span> (addr = in6-&gt;addr_list; addr; addr = addr-&gt;if_next) {
<a name="l00211"></a>00211                                 printk(KERN_INFO <span class="stringliteral">&quot;using scope id %d for %s\n&quot;</span>,
<a name="l00212"></a>00212                                        dev-&gt;ifindex, dev-&gt;name);
<a name="l00213"></a>00213                                 sin6-&gt;sin6_scope_id = dev-&gt;ifindex;
<a name="l00214"></a>00214                                 <span class="keywordflow">return</span> 0;
<a name="l00215"></a>00215                         }
<a name="l00216"></a>00216                 }
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218         <span class="comment">/* If no IPv6 address was configured, hope for the best with the first</span>
<a name="l00219"></a>00219 <span class="comment">         * up interface.</span>
<a name="l00220"></a>00220 <span class="comment">         */</span>
<a name="l00221"></a>00221         for_each_netdev(net, dev) {
<a name="l00222"></a>00222                 <span class="keywordflow">if</span> (!(dev-&gt;flags &amp; IFF_UP))
<a name="l00223"></a>00223                         <span class="keywordflow">continue</span>;
<a name="l00224"></a>00224                 <span class="keywordflow">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK)
<a name="l00225"></a>00225                         <span class="keywordflow">continue</span>;
<a name="l00226"></a>00226                 printk(KERN_INFO <span class="stringliteral">&quot;using scope id %d for %s\n&quot;</span>,
<a name="l00227"></a>00227                        dev-&gt;ifindex, dev-&gt;name);
<a name="l00228"></a>00228                 sin6-&gt;sin6_scope_id = dev-&gt;ifindex;
<a name="l00229"></a>00229                 <span class="keywordflow">return</span> 0;
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231         <span class="comment">/* No interface, that&#39;ll definitely fail */</span>
<a name="l00232"></a>00232         <span class="keywordflow">return</span> -ENODEV;
<a name="l00233"></a>00233 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a16f51d1d1829f7c23407fcbf17139691"></a><!-- doxytag: member="namestack_priv.h::match_v6_address_to_scope" ref="a16f51d1d1829f7c23407fcbf17139691" args="(struct sockaddr_in6 *sin6)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int match_v6_address_to_scope </td>
          <td>(</td>
          <td class="paramtype">struct sockaddr_in6 *&nbsp;</td>
          <td class="paramname"> <em>sin6</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="address_8c_source.html#l00161">161</a> of file <a class="el" href="address_8c_source.html">address.c</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l00719">name_bind_to_fqdn()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00162"></a>00162 {
<a name="l00163"></a>00163         <span class="keyword">struct </span>net *net = &amp;init_net;
<a name="l00164"></a>00164         <span class="keyword">struct </span>net_device *dev;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="comment">/* FIXME: lock net? */</span>
<a name="l00167"></a>00167         for_each_netdev(net, dev) {
<a name="l00168"></a>00168                 <span class="keywordflow">if</span> (!(dev-&gt;flags &amp; IFF_UP))
<a name="l00169"></a>00169                         <span class="keywordflow">continue</span>;
<a name="l00170"></a>00170                 <span class="keywordflow">if</span> (dev-&gt;flags &amp; IFF_LOOPBACK)
<a name="l00171"></a>00171                         <span class="keywordflow">continue</span>;
<a name="l00172"></a>00172                 <span class="keywordflow">if</span> (dev-&gt;ip6_ptr) {
<a name="l00173"></a>00173                         <span class="keyword">struct </span>inet6_dev *in6 = dev-&gt;ip6_ptr;
<a name="l00174"></a>00174                         <span class="keyword">struct </span>inet6_ifaddr *addr;
<a name="l00175"></a>00175 
<a name="l00176"></a>00176                         <span class="keywordflow">for</span> (addr = in6-&gt;addr_list; addr; addr = addr-&gt;if_next)
<a name="l00177"></a>00177                                 <span class="keywordflow">if</span> (!memcmp(&amp;addr-&gt;addr,
<a name="l00178"></a>00178                                     sin6-&gt;sin6_addr.s6_addr,
<a name="l00179"></a>00179                                     <span class="keyword">sizeof</span>(addr-&gt;addr)))
<a name="l00180"></a>00180                                 {
<a name="l00181"></a>00181                                         sin6-&gt;sin6_scope_id = dev-&gt;ifindex;
<a name="l00182"></a>00182                                         <span class="keywordflow">return</span> 0;
<a name="l00183"></a>00183                                 }
<a name="l00184"></a>00184                 }
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186         <span class="keywordflow">return</span> -ENODEV;
<a name="l00187"></a>00187 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ac37ce9d7d05a92ecd217351dfc571834"></a><!-- doxytag: member="namestack_priv.h::name_af_exit" ref="ac37ce9d7d05a92ecd217351dfc571834" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void name_af_exit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="af__name_8c_source.html#l02004">2004</a> of file <a class="el" href="af__name_8c_source.html">af_name.c</a>.</p>

<p>References <a class="el" href="af__name_8c_source.html#l00531">syn_entry::entry</a>, <a class="el" href="af__name_8c_source.html#l00539">name_stream_syns</a>, and <a class="el" href="af__name_8c_source.html#l00538">NAME_SYN_BUCKETS</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00335">namestack_exit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l02005"></a>02005 {
<a name="l02006"></a>02006         <span class="keywordtype">int</span> i;
<a name="l02007"></a>02007 
<a name="l02008"></a>02008         proto_unregister(&amp;<a class="code" href="af__name_8c.html#abd5db91ebd796a3f8758726976c1b8f8">name_stream_proto</a>);
<a name="l02009"></a>02009         proto_unregister(&amp;<a class="code" href="af__name_8c.html#a1a37bdc64eebba463b450ca5aed48d00">name_dgram_proto</a>);
<a name="l02010"></a>02010         sock_unregister(<a class="code" href="af__name_8c.html#a88cf0f8330d7acf8d3347af2baf75c0d">name_family_ops</a>.family);
<a name="l02011"></a>02011         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="af__name_8c.html#ab0d1446d191ef9a97f571715861aa15e">NAME_SYN_BUCKETS</a>; i++)
<a name="l02012"></a>02012         {
<a name="l02013"></a>02013                 <span class="keyword">struct </span><a class="code" href="structsyn__entry.html">syn_entry</a> *<a class="code" href="structsyn__entry.html#a06295c601f813cf596272e58551bcc18">entry</a>;
<a name="l02014"></a>02014                 <span class="keyword">struct </span>hlist_node *node, *next;
<a name="l02015"></a>02015 
<a name="l02016"></a>02016                 hlist_for_each_entry_safe(entry,
<a name="l02017"></a>02017                                           node,
<a name="l02018"></a>02018                                           next,
<a name="l02019"></a>02019                                           &amp;<a class="code" href="af__name_8c.html#ae94ef5341ac94d4f6390192311709d6b">name_stream_syns</a>[i],
<a name="l02020"></a>02020                                           entry)
<a name="l02021"></a>02021                 {
<a name="l02022"></a>02022                         hlist_del(node);
<a name="l02023"></a>02023                         kfree(entry);
<a name="l02024"></a>02024                 }
<a name="l02025"></a>02025         }
<a name="l02026"></a>02026 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aba97cdc2d426374e9a939e5cd64f3c6d"></a><!-- doxytag: member="namestack_priv.h::name_af_init" ref="aba97cdc2d426374e9a939e5cd64f3c6d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int name_af_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="af__name_8c_source.html#l01987">1987</a> of file <a class="el" href="af__name_8c_source.html">af_name.c</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00317">namestack_init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l01988"></a>01988 {
<a name="l01989"></a>01989         <span class="keywordtype">int</span> rc;
<a name="l01990"></a>01990 
<a name="l01991"></a>01991         rc = proto_register(&amp;<a class="code" href="af__name_8c.html#abd5db91ebd796a3f8758726976c1b8f8">name_stream_proto</a>, 1);
<a name="l01992"></a>01992         <span class="keywordflow">if</span> (rc)
<a name="l01993"></a>01993                 <span class="keywordflow">goto</span> out;
<a name="l01994"></a>01994 
<a name="l01995"></a>01995         rc = proto_register(&amp;<a class="code" href="af__name_8c.html#a1a37bdc64eebba463b450ca5aed48d00">name_dgram_proto</a>, 1);
<a name="l01996"></a>01996         <span class="keywordflow">if</span> (rc)
<a name="l01997"></a>01997                 <span class="keywordflow">goto</span> out;
<a name="l01998"></a>01998 
<a name="l01999"></a>01999         rc = sock_register(&amp;<a class="code" href="af__name_8c.html#a88cf0f8330d7acf8d3347af2baf75c0d">name_family_ops</a>);
<a name="l02000"></a>02000 out:
<a name="l02001"></a>02001         <span class="keywordflow">return</span> rc;
<a name="l02002"></a>02002 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aa6e1ff7767ba286a06b81fe430b0e76f"></a><!-- doxytag: member="namestack_priv.h::name_cache_add" ref="aa6e1ff7767ba286a06b81fe430b0e76f" args="(const char *name, struct socket *sock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int name_cache_add </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct socket *&nbsp;</td>
          <td class="paramname"> <em>sock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namecache_8c_source.html#l00073">73</a> of file <a class="el" href="namecache_8c_source.html">namecache.c</a>.</p>

<p>References <a class="el" href="namecache_8c_source.html#l00059">__name_cache_find()</a>, <a class="el" href="namecache_8c_source.html#l00011">name_sock_list::entry</a>, <a class="el" href="namecache_8c_source.html#l00020">lock_name_cache()</a>, <a class="el" href="namecache_8c_source.html#l00054">name_hash()</a>, <a class="el" href="namecache_8c_source.html#l00012">name_sock_list::sock</a>, and <a class="el" href="namecache_8c_source.html#l00025">unlock_name_cache()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l00918">name_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00074"></a>00074 {
<a name="l00075"></a>00075         <span class="keywordtype">int</span> err;
<a name="l00076"></a>00076         u32 bucket = <a class="code" href="namecache_8c.html#a146c3e6f807bb836d9bf21ad8be0e207">name_hash</a>(name);
<a name="l00077"></a>00077         <span class="keyword">struct </span><a class="code" href="structname__sock__list.html">name_sock_list</a> *ptr;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079         <a class="code" href="namecache_8c.html#a8ae772304606167f46e81d0ac73eb6ce">lock_name_cache</a>();
<a name="l00080"></a>00080         ptr = <a class="code" href="namecache_8c.html#a7848b669f978c36fa35e1470743eb0e4">__name_cache_find</a>(name, bucket);
<a name="l00081"></a>00081         <span class="keywordflow">if</span> (ptr) {
<a name="l00082"></a>00082                 err = -EALREADY;
<a name="l00083"></a>00083                 <span class="keywordflow">goto</span> out;
<a name="l00084"></a>00084         }
<a name="l00085"></a>00085         ptr = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structname__sock__list.html">name_sock_list</a>), GFP_ATOMIC);
<a name="l00086"></a>00086         <span class="keywordflow">if</span> (!ptr) {
<a name="l00087"></a>00087                 err = -ENOMEM;
<a name="l00088"></a>00088                 <span class="keywordflow">goto</span> out;
<a name="l00089"></a>00089         }
<a name="l00090"></a>00090         ptr-&gt;<a class="code" href="structname__sock__list.html#a6838df558e8dcdeb9a9dc2df2c2a5d43">sock</a> = <a class="code" href="structname__sock__list.html#a6838df558e8dcdeb9a9dc2df2c2a5d43">sock</a>;
<a name="l00091"></a>00091         INIT_LIST_HEAD(&amp;ptr-&gt;<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>);
<a name="l00092"></a>00092         list_add_tail(&amp;<a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a>[bucket].<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>, &amp;ptr-&gt;<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>);
<a name="l00093"></a>00093         err = 0;
<a name="l00094"></a>00094 out:
<a name="l00095"></a>00095         <a class="code" href="namecache_8c.html#a2de07759137fa58e1f81ea7102a401ac">unlock_name_cache</a>();
<a name="l00096"></a>00096         <span class="keywordflow">return</span> err;
<a name="l00097"></a>00097 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aa1fb6667246cbfbc4f63436093f59535"></a><!-- doxytag: member="namestack_priv.h::name_cache_delete" ref="aa1fb6667246cbfbc4f63436093f59535" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void name_cache_delete </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namecache_8c_source.html#l00099">99</a> of file <a class="el" href="namecache_8c_source.html">namecache.c</a>.</p>

<p>References <a class="el" href="namecache_8c_source.html#l00059">__name_cache_find()</a>, <a class="el" href="namecache_8c_source.html#l00011">name_sock_list::entry</a>, <a class="el" href="namecache_8c_source.html#l00020">lock_name_cache()</a>, <a class="el" href="namecache_8c_source.html#l00054">name_hash()</a>, and <a class="el" href="namecache_8c_source.html#l00025">unlock_name_cache()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l00918">name_register()</a>, and <a class="el" href="af__name_8c_source.html#l00132">name_stream_release()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00100"></a>00100 {
<a name="l00101"></a>00101         u32 bucket = <a class="code" href="namecache_8c.html#a146c3e6f807bb836d9bf21ad8be0e207">name_hash</a>(name);
<a name="l00102"></a>00102         <span class="keyword">struct </span><a class="code" href="structname__sock__list.html">name_sock_list</a> *ptr;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <a class="code" href="namecache_8c.html#a8ae772304606167f46e81d0ac73eb6ce">lock_name_cache</a>();
<a name="l00105"></a>00105         ptr = <a class="code" href="namecache_8c.html#a7848b669f978c36fa35e1470743eb0e4">__name_cache_find</a>(name, bucket);
<a name="l00106"></a>00106         <span class="keywordflow">if</span> (ptr) {
<a name="l00107"></a>00107                 list_del(&amp;ptr-&gt;<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>);
<a name="l00108"></a>00108                 kfree(ptr);
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110         <a class="code" href="namecache_8c.html#a2de07759137fa58e1f81ea7102a401ac">unlock_name_cache</a>();
<a name="l00111"></a>00111 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aed06704ba74d97061ec306c3f2a408d3"></a><!-- doxytag: member="namestack_priv.h::name_cache_free" ref="aed06704ba74d97061ec306c3f2a408d3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void name_cache_free </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namecache_8c_source.html#l00113">113</a> of file <a class="el" href="namecache_8c_source.html">namecache.c</a>.</p>

<p>References <a class="el" href="namecache_8c_source.html#l00011">name_sock_list::entry</a>, and <a class="el" href="namecache_8c_source.html#l00016">name_cache_size</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00335">namestack_exit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00114"></a>00114 {
<a name="l00115"></a>00115         <span class="keywordtype">int</span> i;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="namecache_8c.html#ae53de280f766e69467a000238c3c0ec3">name_cache_size</a>; i++) {
<a name="l00118"></a>00118                 <span class="keyword">struct </span><a class="code" href="structname__sock__list.html">name_sock_list</a> *itr, *next;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120                 list_for_each_entry_safe(itr, next, &amp;<a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a>[i].<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>,
<a name="l00121"></a>00121                                          entry) {
<a name="l00122"></a>00122                         list_del(&amp;itr-&gt;<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>);
<a name="l00123"></a>00123                         kfree(itr);
<a name="l00124"></a>00124                 }
<a name="l00125"></a>00125         }
<a name="l00126"></a>00126         kfree(<a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a>);
<a name="l00127"></a>00127 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a29317552ae54d25f0c09131c2494625b"></a><!-- doxytag: member="namestack_priv.h::name_cache_init" ref="a29317552ae54d25f0c09131c2494625b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int name_cache_init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namecache_8c_source.html#l00030">30</a> of file <a class="el" href="namecache_8c_source.html">namecache.c</a>.</p>

<p>References <a class="el" href="namecache_8c_source.html#l00011">name_sock_list::entry</a>, <a class="el" href="namecache_8c_source.html#l00015">name_cache_shift</a>, <a class="el" href="namecache_8c_source.html#l00016">name_cache_size</a>, and <a class="el" href="namecache_8c_source.html#l00012">name_sock_list::sock</a>.</p>

<p>Referenced by <a class="el" href="main_8c_source.html#l00317">namestack_init()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00031"></a>00031 {
<a name="l00032"></a>00032         <span class="keywordtype">int</span> err;
<a name="l00033"></a>00033 
<a name="l00034"></a>00034         <a class="code" href="namecache_8c.html#a822208f2bdf3c5d8b46792a452c24c2b">name_cache_shift</a> = 4;
<a name="l00035"></a>00035         <a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a> = kmalloc(<a class="code" href="namecache_8c.html#ae53de280f766e69467a000238c3c0ec3">name_cache_size</a> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structname__sock__list.html">name_sock_list</a>),
<a name="l00036"></a>00036                              GFP_ATOMIC);
<a name="l00037"></a>00037         <span class="keywordflow">if</span> (<a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a>) {
<a name="l00038"></a>00038                 <span class="keywordtype">int</span> i;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040                 <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="namecache_8c.html#ae53de280f766e69467a000238c3c0ec3">name_cache_size</a>; i++) {
<a name="l00041"></a>00041                         INIT_LIST_HEAD(&amp;<a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a>[i].<a class="code" href="structname__sock__list.html#a5fd7875e6394d07974bfd19f39960033">entry</a>);
<a name="l00042"></a>00042                         <a class="code" href="namecache_8c.html#abe9247fc17dce0079d23256b274aa2c4">name_cache</a>[i].<a class="code" href="structname__sock__list.html#a6838df558e8dcdeb9a9dc2df2c2a5d43">sock</a> = NULL;
<a name="l00043"></a>00043                 }
<a name="l00044"></a>00044                 err = 0;
<a name="l00045"></a>00045         }
<a name="l00046"></a>00046         <span class="keywordflow">else</span> {
<a name="l00047"></a>00047                 <span class="comment">/* defensive line to protect against a broken caller */</span>
<a name="l00048"></a>00048                 <a class="code" href="namecache_8c.html#a822208f2bdf3c5d8b46792a452c24c2b">name_cache_shift</a> = 0;
<a name="l00049"></a>00049                 err = -ENOMEM;
<a name="l00050"></a>00050         }
<a name="l00051"></a>00051         <span class="keywordflow">return</span> err;
<a name="l00052"></a>00052 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aee0a1ed42b28379c58f090c8b5d06aa5"></a><!-- doxytag: member="namestack_priv.h::name_cancel_query" ref="aee0a1ed42b28379c58f090c8b5d06aa5" args="(void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void name_cancel_query </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8bda9733b25a90bc533e4503c32830ad"></a><!-- doxytag: member="namestack_priv.h::name_delete_registration" ref="a8bda9733b25a90bc533e4503c32830ad" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void name_delete_registration </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="main_8c_source.html#l00467">467</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

<p>References <a class="el" href="main_8c_source.html#l00011">daemon_pid</a>, <a class="el" href="namestacknl_8h_source.html#l00017">NAME_STACK_REGISTER_DELETE</a>, and <a class="el" href="main_8c_source.html#l00118">namestack_send_message()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l00132">name_stream_release()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00468"></a>00468 {
<a name="l00469"></a>00469         <span class="keywordtype">int</span> err;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         <span class="keywordflow">if</span> (!<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>) {
<a name="l00472"></a>00472                 printk(KERN_WARNING <span class="stringliteral">&quot;no resolver daemon, unable to send query\n&quot;</span>);
<a name="l00473"></a>00473                 err = -ENOSYS;
<a name="l00474"></a>00474         }
<a name="l00475"></a>00475         <span class="keywordflow">else</span> {
<a name="l00476"></a>00476                 printk(KERN_INFO <span class="stringliteral">&quot;deleting registered name %s\n&quot;</span>, name);
<a name="l00477"></a>00477                 <span class="comment">/* FIXME:  who handles retrying in case of failure? */</span>
<a name="l00478"></a>00478                 err = <a class="code" href="main_8c.html#a7c9e241b27d9bb9cbfcbf78e83e8c4d8">namestack_send_message</a>(<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>,
<a name="l00479"></a>00479                                              <a class="code" href="namestacknl_8h.html#a99fb83031ce9923c84392b4e92f956b5ac6a06cd923bbe3eeff7f306d7c54d67d">NAME_STACK_REGISTER_DELETE</a>,
<a name="l00480"></a>00480                                              name, strlen(name) + 1);
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ac90990b1e38414ac068ce97f0c469e4e"></a><!-- doxytag: member="namestack_priv.h::name_fully_qualify" ref="ac90990b1e38414ac068ce97f0c469e4e" args="(const char *name, qualify_cb cb, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int name_fully_qualify </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namestack__priv_8h.html#ae0ee61a92e06c6d36d46f60beef3d27d">qualify_cb</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="main_8c_source.html#l00400">400</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

<p>References <a class="el" href="main_8c_source.html#l00011">daemon_pid</a>, <a class="el" href="namestacknl_8h_source.html#l00013">NAME_STACK_QUALIFY_QUERY</a>, and <a class="el" href="main_8c_source.html#l00348">namestack_send_message_tracked()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l01020">name_qualify_and_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00401"></a>00401 {
<a name="l00402"></a>00402         <span class="keywordtype">int</span> err;
<a name="l00403"></a>00403 
<a name="l00404"></a>00404         <span class="keywordflow">if</span> (!<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>) {
<a name="l00405"></a>00405                 printk(KERN_WARNING <span class="stringliteral">&quot;no resolver daemon, unable to send query\n&quot;</span>);
<a name="l00406"></a>00406                 err = -ENOSYS;
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408         <span class="keywordflow">else</span> {
<a name="l00409"></a>00409                 printk(KERN_INFO <span class="stringliteral">&quot;qualifying %s\n&quot;</span>, name);
<a name="l00410"></a>00410                 <span class="comment">/* FIXME:  who handles retrying in case of failure? */</span>
<a name="l00411"></a>00411                 err = <a class="code" href="main_8c.html#aeb93f5ca5ca3fac7e71bdb3d0e5ba2d7">namestack_send_message_tracked</a>(<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>,
<a name="l00412"></a>00412                                                      <a class="code" href="namestacknl_8h.html#a99fb83031ce9923c84392b4e92f956b5a58c8aa74a0c6bba5181288e66eddbd95">NAME_STACK_QUALIFY_QUERY</a>,
<a name="l00413"></a>00413                                                      name, strlen(name) + 1,
<a name="l00414"></a>00414                                                      cb, data);
<a name="l00415"></a>00415         }
<a name="l00416"></a>00416         <span class="keywordflow">return</span> err;
<a name="l00417"></a>00417 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="af9ebf7c5c4b9e21647f9fad73789d1c4"></a><!-- doxytag: member="namestack_priv.h::name_send_query" ref="af9ebf7c5c4b9e21647f9fad73789d1c4" args="(const char *name, query_resolv_cb cb, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int name_send_query </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namestack__priv_8h.html#aa467a35f7adb45db01b0a959525737a5">query_resolv_cb</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="main_8c_source.html#l00381">381</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

<p>References <a class="el" href="main_8c_source.html#l00011">daemon_pid</a>, <a class="el" href="namestacknl_8h_source.html#l00011">NAME_STACK_NAME_QUERY</a>, and <a class="el" href="main_8c_source.html#l00348">namestack_send_message_tracked()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l01355">name_stream_connect()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00382"></a>00382 {
<a name="l00383"></a>00383         <span class="keywordtype">int</span> err;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385         <span class="keywordflow">if</span> (!<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>) {
<a name="l00386"></a>00386                 printk(KERN_WARNING <span class="stringliteral">&quot;no resolver daemon, unable to send query\n&quot;</span>);
<a name="l00387"></a>00387                 err = -ENOSYS;
<a name="l00388"></a>00388         }
<a name="l00389"></a>00389         <span class="keywordflow">else</span> {
<a name="l00390"></a>00390                 printk(KERN_INFO <span class="stringliteral">&quot;resolving %s\n&quot;</span>, name);
<a name="l00391"></a>00391                 <span class="comment">/* FIXME:  who handles retrying in case of failure? */</span>
<a name="l00392"></a>00392                 err = <a class="code" href="main_8c.html#aeb93f5ca5ca3fac7e71bdb3d0e5ba2d7">namestack_send_message_tracked</a>(<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>,
<a name="l00393"></a>00393                                                      <a class="code" href="namestacknl_8h.html#a99fb83031ce9923c84392b4e92f956b5a1a40ef38ac3a4608c7dbe084e5a065d8">NAME_STACK_NAME_QUERY</a>,
<a name="l00394"></a>00394                                                      name, strlen(name) + 1,
<a name="l00395"></a>00395                                                      cb, data);
<a name="l00396"></a>00396         }
<a name="l00397"></a>00397         <span class="keywordflow">return</span> err;
<a name="l00398"></a>00398 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ab952bacca3b7e5f0795ba6304a36cfd4"></a><!-- doxytag: member="namestack_priv.h::name_send_registration" ref="ab952bacca3b7e5f0795ba6304a36cfd4" args="(const char *name, const struct in6_addr *v6_addresses, int num_v6_addresses, const __be32 *v4_addresses, int num_v4_addresses, register_cb cb, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int name_send_registration </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in6_addr *&nbsp;</td>
          <td class="paramname"> <em>v6_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_v6_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const __be32 *&nbsp;</td>
          <td class="paramname"> <em>v4_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_v4_addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namestack__priv_8h.html#abc9db88094d622c5f1f6b811da3c9693">register_cb</a>&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="main_8c_source.html#l00419">419</a> of file <a class="el" href="main_8c_source.html">main.c</a>.</p>

<p>References <a class="el" href="main_8c_source.html#l00011">daemon_pid</a>, <a class="el" href="namestacknl_8h_source.html#l00015">NAME_STACK_REGISTER_QUERY</a>, and <a class="el" href="main_8c_source.html#l00348">namestack_send_message_tracked()</a>.</p>

<p>Referenced by <a class="el" href="af__name_8c_source.html#l00918">name_register()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00425"></a>00425 {
<a name="l00426"></a>00426         <span class="keywordtype">int</span> err;
<a name="l00427"></a>00427 
<a name="l00428"></a>00428         <span class="keywordflow">if</span> (!<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>) {
<a name="l00429"></a>00429                 printk(KERN_WARNING <span class="stringliteral">&quot;no resolver daemon, unable to send query\n&quot;</span>);
<a name="l00430"></a>00430                 err = -ENOSYS;
<a name="l00431"></a>00431         }
<a name="l00432"></a>00432         <span class="keywordflow">else</span> {
<a name="l00433"></a>00433                 <span class="keywordtype">char</span> *payload, *ptr;
<a name="l00434"></a>00434                 <span class="keywordtype">size_t</span> name_len, len;
<a name="l00435"></a>00435 
<a name="l00436"></a>00436                 printk(KERN_INFO <span class="stringliteral">&quot;registering %s\n&quot;</span>, name);
<a name="l00437"></a>00437                 name_len = strlen(name) + 1;
<a name="l00438"></a>00438                 len = name_len;
<a name="l00439"></a>00439                 len += <span class="keyword">sizeof</span>(int) + num_v6_addresses * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr);
<a name="l00440"></a>00440                 len += <span class="keyword">sizeof</span>(int) + num_v4_addresses * <span class="keyword">sizeof</span>(__be32);
<a name="l00441"></a>00441                 err = -ENOMEM;
<a name="l00442"></a>00442                 payload = kmalloc(len, GFP_ATOMIC);
<a name="l00443"></a>00443                 <span class="keywordflow">if</span> (!payload)
<a name="l00444"></a>00444                         <span class="keywordflow">goto</span> out;
<a name="l00445"></a>00445                 ptr = payload;
<a name="l00446"></a>00446                 memcpy(ptr, name, name_len);
<a name="l00447"></a>00447                 ptr += name_len;
<a name="l00448"></a>00448                 memcpy(ptr, &amp;num_v6_addresses, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00449"></a>00449                 ptr += <span class="keyword">sizeof</span>(int);
<a name="l00450"></a>00450                 memcpy(ptr, v6_addresses,
<a name="l00451"></a>00451                        num_v6_addresses * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in6_addr));
<a name="l00452"></a>00452                 ptr += num_v6_addresses * <span class="keyword">sizeof</span>(<span class="keyword">struct </span>in6_addr);
<a name="l00453"></a>00453                 memcpy(ptr, &amp;num_v4_addresses, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00454"></a>00454                 ptr += <span class="keyword">sizeof</span>(int);
<a name="l00455"></a>00455                 memcpy(ptr, v4_addresses, num_v4_addresses * <span class="keyword">sizeof</span>(__be32));
<a name="l00456"></a>00456                 <span class="comment">/* FIXME:  who handles retrying in case of failure? */</span>
<a name="l00457"></a>00457                 err = <a class="code" href="main_8c.html#aeb93f5ca5ca3fac7e71bdb3d0e5ba2d7">namestack_send_message_tracked</a>(<a class="code" href="main_8c.html#a6ebb190fa1a28b47fee72d4be9e6394a">daemon_pid</a>,
<a name="l00458"></a>00458                                                      <a class="code" href="namestacknl_8h.html#a99fb83031ce9923c84392b4e92f956b5ac4c9d21ed1f2b2c9c2d9544d59e4a6e6">NAME_STACK_REGISTER_QUERY</a>,
<a name="l00459"></a>00459                                                      payload, len,
<a name="l00460"></a>00460                                                      cb, data);
<a name="l00461"></a>00461                 kfree(payload);
<a name="l00462"></a>00462         }
<a name="l00463"></a>00463 out:
<a name="l00464"></a>00464         <span class="keywordflow">return</span> err;
<a name="l00465"></a>00465 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a5e5b37b81978789054ddc587e3af21e6"></a><!-- doxytag: member="namestack_priv.h::name_stream_sk" ref="a5e5b37b81978789054ddc587e3af21e6" args="(const struct sock *sk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structname__stream__sock.html">name_stream_sock</a>* name_stream_sk </td>
          <td>(</td>
          <td class="paramtype">const struct sock *&nbsp;</td>
          <td class="paramname"> <em>sk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="namestack__priv_8h_source.html#l00025">25</a> of file <a class="el" href="namestack__priv_8h_source.html">namestack_priv.h</a>.</p>

<p>Referenced by <a class="el" href="namecache_8c_source.html#l00059">__name_cache_find()</a>, <a class="el" href="af__name_8c_source.html#l01848">name_alloc_stream_socket()</a>, <a class="el" href="af__name_8c_source.html#l01020">name_qualify_and_register()</a>, <a class="el" href="af__name_8c_source.html#l00994">name_qualify_cb()</a>, <a class="el" href="af__name_8c_source.html#l00918">name_register()</a>, <a class="el" href="af__name_8c_source.html#l00785">name_register_cb()</a>, <a class="el" href="af__name_8c_source.html#l01569">name_stream_accept()</a>, <a class="el" href="af__name_8c_source.html#l01065">name_stream_bind()</a>, <a class="el" href="af__name_8c_source.html#l01355">name_stream_connect()</a>, <a class="el" href="af__name_8c_source.html#l01264">name_stream_connect_to_resolved_name()</a>, <a class="el" href="af__name_8c_source.html#l01213">name_stream_connect_to_v4_address()</a>, <a class="el" href="af__name_8c_source.html#l01122">name_stream_connect_to_v6_address()</a>, <a class="el" href="af__name_8c_source.html#l01718">name_stream_getname()</a>, <a class="el" href="af__name_8c_source.html#l01737">name_stream_listen()</a>, <a class="el" href="af__name_8c_source.html#l01320">name_stream_query_resolve()</a>, <a class="el" href="af__name_8c_source.html#l01789">name_stream_recvmsg()</a>, <a class="el" href="af__name_8c_source.html#l00132">name_stream_release()</a>, and <a class="el" href="af__name_8c_source.html#l01771">name_stream_sendmsg()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00026"></a>00026 {
<a name="l00027"></a>00027         <span class="keywordflow">return</span> (<span class="keyword">struct</span> <a class="code" href="structname__stream__sock.html">name_stream_sock</a> *)sk;
<a name="l00028"></a>00028 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Tue Jan 18 21:11:50 2011 for Name-based sockets - module by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
